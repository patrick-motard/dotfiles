# -*- mode: sh; -*-
# vim: set ft=zsh:
# ~/.zsh/.zshrc
# Reload zsh config - use exec to start fresh shell
alias sz="exec zsh"
alias csz="cat $ZDOTDIR/.zshrc"
alias catsz="cat $ZDOTDIR/.zshrc"
alias catrc="cat $ZDOTDIR/.zshrc"

# ~/.zshenv
alias szenv="source ~/.zshenv"
alias czenv="cat ~/.zshenv"
alias catzenv="cat ~/.zshenv"
alias catenv="cat ~/.zshenv"

# Directories
alias ls="eza"
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias .....="cd ../../../.."
alias c="cd ~/code"
alias h="cd ~"
alias l="ls -l"
alias ll="ls -al"
alias localbin="cd ~/.local/bin"
alias rmrf="rm -rf"

# Files
alias x="chmod +x"

# Git
# nice shorthand,plus it gets rid of annoyingly launching ghostscript on accident.
alias ga="git add"
alias gaa="git add ."
alias gau="git add -u" # git add unstaged only

alias gb="git branch"
alias gbl="git branch -l"

alias gc="git commit --verbose"
alias gca="git commit --amend"
alias gcb="git checkout -b"
alias gcm="git commit -m"

alias gd="git diff"
alias gds="git diff --staged"

alias gl="git log"
# fancy git
alias glog="git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"
alias glogv="glog | vim -" # fancy git log opened in vim, useful for searching and copying
alias glogp="glog -p" # fancy git log, show diff for each commit
alias glv="git log | vim -" # git log opened in vim, useful for searching and copying

alias gp="git push"
alias gpf="git push --force-with-lease"
# git push and set upstream to current branch
function push_upstream () {
    git push -u origin $(git branch | grep "*" | awk -F " " '{print $NF}')
}
alias gpu=push_upstream
alias lg="lazygit"
alias gs="git status"

# Git Worktrees
# Base directory for all worktree-managed repos
export WORKTREE_DIR="$HOME/code/worktrees"

# Clone a repo as a bare repo for worktree use
# Usage: gwt-clone <repo-url> [project-name]
function gwt-clone() {
    local repo_url="$1"
    local project_name="${2:-$(basename -s .git "$repo_url")}"
    local project_dir="$WORKTREE_DIR/$project_name"

    if [[ -z "$repo_url" ]]; then
        echo "Usage: gwt-clone <repo-url> [project-name]"
        return 1
    fi

    mkdir -p "$project_dir"
    git clone --bare "$repo_url" "$project_dir/.git"

    # Configure the bare repo to fetch all remote branches
    git --git-dir="$project_dir/.git" config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
    git --git-dir="$project_dir/.git" fetch origin

    # Create a worktree for the default branch
    local default_branch
    default_branch=$(git --git-dir="$project_dir/.git" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's|refs/remotes/origin/||')
    if [[ -z "$default_branch" ]]; then
        default_branch="main"
    fi

    git --git-dir="$project_dir/.git" worktree add "$project_dir/$default_branch" "$default_branch"
    echo "Worktree ready: $project_dir/$default_branch"
    echo "Use Alt-s > Ctrl-w in tmux to switch worktrees"
    cd "$project_dir/$default_branch"
}

# Add a worktree for an existing or new branch
# Usage: gwt-add <branch-name> [base-branch]
function gwt-add() {
    local branch="$1"
    local base="${2:-HEAD}"

    if [[ -z "$branch" ]]; then
        echo "Usage: gwt-add <branch-name> [base-branch]"
        return 1
    fi

    # Find the bare repo's git dir
    local git_common_dir
    git_common_dir=$(git rev-parse --git-common-dir 2>/dev/null)
    if [[ -z "$git_common_dir" || "$git_common_dir" == "." ]]; then
        echo "Not in a worktree-managed repo"
        return 1
    fi

    local project_dir=$(dirname "$git_common_dir")
    local worktree_path="$project_dir/$branch"

    # Check if branch exists on remote
    if git show-ref --verify --quiet "refs/remotes/origin/$branch" 2>/dev/null; then
        git worktree add "$worktree_path" "$branch"
    else
        git worktree add -b "$branch" "$worktree_path" "$base"
    fi

    echo "Created worktree at $worktree_path"
    cd "$worktree_path"
}

# List worktrees for the current project
alias gwt-ls="git worktree list"

# Remove a worktree
# Usage: gwt-rm <branch-name>
function gwt-rm() {
    local branch="$1"
    if [[ -z "$branch" ]]; then
        echo "Usage: gwt-rm <branch-name>"
        return 1
    fi
    git worktree remove "$(dirname "$(git rev-parse --git-common-dir)")/$branch"
    echo "Removed worktree $branch"
}

# Navigate to worktrees directory
alias wt="cd $HOME/code/worktrees"

# Ruby
alias bi="bundle install"

# Homebrew with Ansible sync
# brew-ansible-sync functions (brewi, brewci, brewtap, etc)
# Sourced from scripts repo
if [[ -f "$HOME/code/scripts/brew-ansible-sync" ]]; then
  source "$HOME/code/scripts/brew-ansible-sync"
else
  echo "Warning: brew-ansible-sync script not found at $HOME/code/scripts/brew-ansible-sync"
  echo "Possible cause: scripts repo not cloned yet. Run 'dotansible' to clone it."
fi

#region Program Related

## Chezmoi
export MOIDIR="$HOME/.local/share/chezmoi"
alias moi="chezmoi"
# cd to dotfiles repo.
alias moicd="cd $MOIDIR"
# Run a git command on dotfiles repo from any dir.
alias gmoi="git -C $MOIDIR"
# Open dotfiles repo in editor.
alias edit="pushd $MOIDIR && $EDITOR $MOIDIR"
# Check system state across machines.
alias ssc="system-state-check"

# Apply and source changes.
ma() {
  chezmoi apply
  [[ -d ~/code/dotfiles-private ]] && chezmoi -S ~/code/dotfiles-private apply
  sz
}

# Apply and source changes with pre-flight system state check.
mam() {
  # Run system state check first
  system-state-check
  local exit_code=$?

  if [[ $exit_code -eq 1 ]] || [[ $exit_code -eq 2 ]]; then
    # Issues found, ask user
    echo ""
    read -q "REPLY?Issues found. Continue with chezmoi apply? (y/n) "
    echo ""
    if [[ $REPLY != "y" ]]; then
      echo "Aborted."
      return 1
    fi
  fi

  # Proceed with apply and reload
  chezmoi apply
  [[ -d ~/code/dotfiles-private ]] && chezmoi -S ~/code/dotfiles-private apply
  sz
}

alias moi_add_nvim="chezmoi add ~/.config/nvim && rm $MOIDIR/dot_config/nvim/lazy-lock.json"

## Ansible
# Run dotfiles ansible playbook. Uses hostname-specific inventory if available.
# Usage: dotansible [options] [tag] [ansible args...]
#        dotansible              - run full playbook
#        dotansible tags         - list available tags
#        dotansible -i           - select tag interactively with fzf
#        dotansible brew         - run only brew tasks
#        dotansible zsh --check  - dry-run zsh tasks
dotansible() {
  local inventory playbook cmd
  playbook="$MOIDIR/ansible/main.yml"
  if [[ -f "$MOIDIR/ansible/inventory/$HOST.yml" ]]; then
    inventory="$MOIDIR/ansible/inventory/$HOST.yml"
  else
    inventory="$MOIDIR/ansible/inventory/main.yml"
  fi

  case "$1" in
    tags|--list-tags)
      cmd=(ansible-playbook "$playbook" -i "$inventory" --list-tags)
      ;;
    -i|--interactive)
      shift
      local tag
      tag=$(ansible-playbook "$playbook" -i "$inventory" --list-tags 2>/dev/null \
        | grep -oE '\b[a-z][-a-z0-9_]*\b' \
        | sort -u \
        | fzf --prompt="Select tag: " --height=40% --reverse)
      [[ -z "$tag" ]] && return 0
      cmd=(ansible-playbook "$playbook" -i "$inventory" --tags "$tag" "$@")
      ;;
    "")
      cmd=(ansible-playbook "$playbook" -i "$inventory")
      ;;
    -*)
      cmd=(ansible-playbook "$playbook" -i "$inventory" "$@")
      ;;
    *)
      local tag="$1"
      shift
      cmd=(ansible-playbook "$playbook" -i "$inventory" --tags "$tag" "$@")
      ;;
  esac

  echo "Running: ${cmd[*]}"
  "${cmd[@]}"
}

## Nodenv
alias update_nodenv_build="git -C ~/.nodenv/plugins/node-build pull"

# FZF
# function open_in_vscode {
#     code $(fzf)
# }

# alias lfunctions="print -l ${(ok)functions[(I)[^_]*]}"
# alias lfn=lfunctions
# alias sfn="lfn | fzf"

# function rfn {
#     $(sfn)
# }

## Able
function start_able_dev {
    pkill Able
    pushd ~/code/able
    npm run electron:serve
    popd
}
alias abledev=start_able_dev

## Vim
alias vim="nvim"
alias v="nvim"
# alias vv="nvim ."
alias vd="pushd $MOIDIR && nvim ."
alias nvimcd="cd ~/.config/nvim"

## Grep
# Colorize matches in grep output.
alias grep="grep --color=auto"

# Search through history.
# Example:
# $ hgrep ls
# 17625  ls /usr/bin
# 17626  ls /usr/bin | grep firefox
# 17641  ls
function hgrep() {
    history | grep "${1}"
}

#endregion Programs

{{ if eq .chezmoi.hostname "GVXPDWWKWG" -}}
#region Zendesk-Specific Configuration
# Directories
alias zen="cd ~/code/zendesk"
function start_bill() {
    pushd ~/code/zendesk/billing
    zdi zendesk_billing -d restart -e UNICORN_TIMEOUT=600000
}
#endregion Zendesk-Specific Configuration
{{ end -}}

function generate_password() {
    if [[ $isLinux == 0 ]]; then
       password=$(< /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c 32; echo;)
    else
        password=$(env LC_CTYPE=C tr -dc "a-zA-Z0-9-_\$\?" < /dev/urandom | head -c 32)
    fi

    echo $password | pbcopy
    echo "New password copied to clipboard."
}

alias passgen=generate_password

#startregion Tools
alias ns="new_script --path . --name"
alias nt="new_script --name"
#endregion Tools

# Alacritty command line
#
# Tmux
#
# Start tmux: connect to first session if server running, otherwise create new session
alias t='tmux list-sessions &>/dev/null && sesh connect "$(sesh list -t | head -1)" || tmux new-session'
alias tmux_uninstall_plugins="~/.tmux/plugins/tpm/bin/clean_plugins"


# List all nvim configurations and launch nvim with the configuration you choose.
# Source: https://michaeluloth.com/neovim-switch-configs/
# This environment variable is the name of the folder in ~/.config/nvim that contains the
# configuration you want to use for neovim.
export NVIM_APPNAME="nvim-custom"
vv() {
  # Assumes all configs exist in directories named ~/.config/nvim-*
  local config=$(fd --max-depth 1 --glob 'nvim-*' ~/.config | fzf --prompt="Neovim Configs > " --height=~50% --layout=reverse --border --exit-0)

  # If I exit fzf without selecting a config, don't open Neovim
  [[ -z $config ]] && echo "No config selected" && return

  # Open Neovim with the selected config
  NVIM_APPNAME=$(basename $config) nvim $@
}
